import React from 'react';
import useStore from '../../store/index.js';
import styles from './domino_stack.module.scss';

import Domino from './domino.jsx';

const TestProgress = () => {
  const { whichFocus, attempt } = useStore((state) => state.testSlice.currentScreen);
  const ptr = useStore((state) => state.testSlice.currentScreen.recall_dominoPointers[whichFocus.pairIndex][whichFocus.leftOrRight]);
  return (
    <div>
      <div>
        RECALL_DOMINOPOINTER {ptr.namesOrObjects}; lap: {ptr.lap}; pairIndex: {ptr.pairIndex}; {ptr.leftOrRight}; focused: {ptr.focused}; thisPairNeedsReinforcement: {ptr.thisPairNeedsReinforcement.toString()}.
      </div>
      <div>
        WHICHFOCUS pairIndex: {whichFocus.pairIndex}; leftOrRight: {whichFocus.leftOrRight}.
      </div>
      <div>
        ATTEMPT {attempt}
      </div>
    </div>
  );
};

const Recall = () => {
  const stackResetKey = useStore((state) => state.testSlice.currentScreen.recallPointer.stackResetKey); // reset key for the whole DominoStack, for when "lap" changes. (since each domino's targetString & userEntry needs to get reinitialized/wiped clean.)
  const dominoResetKeys = useStore((state) => state.testSlice.currentScreen.recallPointer.dominoResetKeys);
  const dominoStackHeight = useStore((state) => state.testSlice.currentScreen.recallPointer.dominoStackHeight);
  // const setCorrect = useStore((state) => state.testSlice.setCorrect);

  return (
    <div>
      <TestProgress />
      <div key={stackResetKey} className={styles.dominoStack}>
        {Array.from({ length: dominoStackHeight }).map((_, pairIndex) => ( // these dominoes get their pairIndices generated by map() and are passed them as a prop.
          <div key={pairIndex} className={styles.dominoPair}>
            {/* Keys must be unique. They're required for mapping lists in React. They can also be incremented to reset component state (like the innermost key and outermost key, here). Key is internal to react and isn't available as a prop. */}
            <Domino
              key={dominoResetKeys[pairIndex].leftHalf}
              pairIndex={pairIndex} // There are multiple dominoes onscreen at once, so they need 2 props to access the correct currentScreen dominoPointer in the store.
              leftOrRight="leftHalf"
            />
            <Domino
              key={dominoResetKeys[pairIndex].rightHalf}
              pairIndex={pairIndex}
              leftOrRight="rightHalf"
            />

            {/* Placeholder for progressbar */}
          </div>
        ))}
      </div>
    </div>
  );
};

{ /* <button onClick={() => setCorrect.recall('IDK')} // IDK button is there, always. (extra points for a css that makes it fade in.) // IDK button should only be clickable when whichFocus.leftOrRight === 'rightHalf' and the whichFocus.pairIndex is its pairIndex. & it should be hidden & not clickable when thisPairNeedsReinforcement === true. IDK would try to create a second nested results structure...
            >IDK
            </button> */ }

export default Recall;
