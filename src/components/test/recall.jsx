import React, { useEffect, useRef, useCallback } from 'react';
import useStore from '../../store/index.js';
import styles from './domino_stack.module.scss';
import stylesWelcome from '../welcome/welcome.module.scss';

import Domino from './domino.jsx';

const TestProgress = () => {
  const { whichFocus, attempt } = useStore((state) => state.testSlice.currentScreen);
  const ptr = useStore((state) => state.testSlice.currentScreen.recall_dominoPointers[whichFocus.pairIndex][whichFocus.leftOrRight]);
  return (
    <div style={{ textAlign: 'center' }}>
      <div>
        lap {ptr.lap + 1}, pairIndex {ptr.pairIndex + 1}, attempt {attempt + 1}
      </div>
      {ptr.thisPairNeedsReinforcement && (
        <div>
          reinforcement rep: {ptr.thisPairNeedsReinforcement.toString()}
        </div>
      )}
    </div>
  );
};

const Recall = () => {
  // original recallPointer hooks
  const stackResetKey = useStore((state) => state.testSlice.currentScreen.recallPointer.stackResetKey); // reset key for the whole DominoStack, for when "lap" changes. (since each domino's targetString & userEntry needs to get reinitialized/wiped clean.)
  const dominoResetKeys = useStore((state) => state.testSlice.currentScreen.recallPointer.dominoResetKeys);
  const dominoStackHeightBoth = useStore((state) => state.testSlice.currentScreen.recallPointer.dominoStackHeight);
  const { namesOrObjects } = useStore((state) => state.testSlice.currentScreen.counterbalanced); // I didn't anticipate that Recall would need to know this, and neglected to put it in recallPointer
  // for the IDK button
  const setCorrect = useStore((state) => state.testSlice.setCorrect);
  const whichFocus = useStore((state) => state.testSlice.currentScreen.whichFocus);
  const { thisPairNeedsReinforcement } = useStore((state) => state.testSlice.currentScreen.recall_dominoPointers[whichFocus.pairIndex][whichFocus.leftOrRight]);

  // FOCUS LOGIC (now focus is centrally managed in Recall)
  const focusedDominoRef = useRef(null); // Store the ref of the currently focused domino; currently null. Each domino receives focusedDominoRef, to provide it with that domino's ref IF that domino's focused === true.
  // Centralized focus restoration function. Called by useEffect[whichFocus] and handleBlur, inside the Domino.
  const restoreFocus = useCallback(() => { // useCallback memoizes this function, so it persists across Recall renders. (Normally functions are recreated each render cycle, so their ref changes; if you're passing the function ref as a prop, that would cause the child components to rerender unnecessarily.)
    if (focusedDominoRef.current) { // due to "closure", calling the restoreFocus() ref inside Domino does not require passing focusedDominoRef as an argument. It remembers this argument from its original lexical environment.
      focusedDominoRef.current.focus();
    }
  }, []); // create the function once, on the first render.
  // Whenever whichFocus changes, focus the correct domino. // this is the only valid reason focus should change. Note I'm still using the "focused" key, though, since that's what's accessible inside the dominoPointer
  useEffect(() => {
    restoreFocus();
  }, [whichFocus]);

  return (
    <div>
      <div key={stackResetKey} className={`${stylesWelcome.container} ${styles[(namesOrObjects === 'names') ? 'dominoStack_names' : 'dominoStack_objects']}`}>
        {Array.from({ length: dominoStackHeightBoth[namesOrObjects] }).map((_, pairIndex) => ( // these dominoes get their pairIndices generated by map() and are passed them as a prop.
          <span key={pairIndex} className={styles.dominoPairIDK}>
            {/* Keys must be unique. They're required for mapping lists in React. They can also be incremented to reset component state (like the innermost key and outermost key, here). Key is internal to react and isn't available as a prop. */}
            <Domino
              key={dominoResetKeys[pairIndex].leftHalf}
              pairIndex={pairIndex} // There are multiple dominoes onscreen at once, so they need 2 props to access the correct currentScreen dominoPointer in the store.
              leftOrRight="leftHalf"
              dominoRefToFocus={focusedDominoRef} // Pass ref setter
              restoreFocus={restoreFocus} // pass the function ref, to be called while handling blur events
              hidePair={(pairIndex > whichFocus.pairIndex)}
            />
            <Domino
              key={dominoResetKeys[pairIndex].rightHalf}
              pairIndex={pairIndex}
              leftOrRight="rightHalf"
              dominoRefToFocus={focusedDominoRef} // Pass ref setter
              restoreFocus={restoreFocus} // pass the function ref, to be called while handling blur events
              hidePair={(pairIndex > whichFocus.pairIndex)}
            />
            {/* // IDK button should only be clickable when whichFocus.leftOrRight === 'rightHalf' and the whichFocus.pairIndex is its pairIndex. & it should be hidden & not clickable when thisPairNeedsReinforcement === true. IDK would try to create a second nested results structure... */}
            <button
              onClick={() => setCorrect.recall('IDK')}
              className={`${styles.buttonIDK} ${(whichFocus.leftOrRight === 'rightHalf' && whichFocus.pairIndex === pairIndex && !thisPairNeedsReinforcement) ? '' : styles.unclickable}`}
            >IDK
            </button>
            {/* Placeholder for progressbar */}
          </span>
        ))}
      </div>
      <TestProgress />
    </div>
  );
};

export default Recall;
